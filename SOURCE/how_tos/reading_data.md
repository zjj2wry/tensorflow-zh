# 数据读取 <a class="md-anchor" id="AUTOGENERATED-reading-data"></a>

TensorFlow程序读取数据一共有3种方法:

*   供给数据(Feeding)： 在TensorFlow程序运行的每一步， 让Python代码来供给数据。
*   从文件读取数据： 在TensorFlow图的起始， 让一个输入管线从文件中读取数据。
*   预加载数据： 在TensorFlow图中定义常量或变量来保存所有数据(仅适用于数据量比较小的情况)。

<!-- TOC-BEGIN This section is generated by neural network: DO NOT EDIT! -->
## 目录
### [数据读取](#AUTOGENERATED-reading-data)
* [供给数据(Feeding)](#Feeding)
* [从文件读取数据](#AUTOGENERATED-reading-from-files)
  * [文件名, 乱序(shuffling), 和最大训练迭代数(epoch limits)](#AUTOGENERATED-filenames--shuffling--and-epoch-limits)
  * [文件格式](#AUTOGENERATED-file-formats)
  * [预处理](#AUTOGENERATED-preprocessing)
  * [批处理](#AUTOGENERATED-batching)
  * [使用`QueueRunner`创建预读线程](#QueueRunner)
  * [对记录进行过滤或者为每个纪录创建多个样本](#AUTOGENERATED-filtering-records-or-producing-multiple-examples-per-record)
  * [序列化输入数据(Sparse input data)](#AUTOGENERATED-sparse-input-data)
* [预加载数据](#AUTOGENERATED-preloaded-data)
* [多管线输入](#AUTOGENERATED-multiple-input-pipelines)


<!-- TOC-END This section was generated by neural network, THANKS FOR READING! -->

## 供给数据 <a class="md-anchor" id="Feeding"></a>

TensorFlow的数据供给机制允许你在TensorFlow运算图中将数据注入到任一张量中。因此，python运算可以把数据直接设置到TensorFlow图中。

通过给run()或者eval()函数输入`feed_dict`参数， 可以启动运算过程。

```python
with tf.Session():
  input = tf.placeholder(tf.float32)
  classifier = ...
  print classifier.eval(feed_dict={input: my_python_preprocessing_fn()})
```

虽然你可以使用常量和变量来替换任何一个张量， 但是最好的做法应该是使用[`placeholder` op](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#placeholder)节点。设计`placeholder`节点的唯一的意图就是为了提供数据供给(feeding)的方法。`placeholder`节点被声明的时候是未初始化的， 也不包含数据， 如果没有为它供给数据， 则TensorFlow运算的时候会产生错误， 所以千万不要忘了为`placeholder`提供数据。

可以在[`tensorflow/g3doc/tutorials/mnist/fully_connected_feed.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/g3doc/tutorials/mnist/fully_connected_feed.py)找到使用`placeholder`和MNIST训练的例子，[MNIST tutorial](tensorflow-zh/SOURCE/tutorials/mnist/tf/index.md)也讲述了这一例子。

## 从文件读取数据 <a class="md-anchor" id="AUTOGENERATED-reading-from-files"></a>

一种典型的文件读取管线会包含下面这些步骤：

1.  文件名列表
2.  *可配置的* 文件名乱序(shuffling)
3.  *可配置的* 最大训练迭代数(epoch limit)
4.  文件名队列
5.  针对输入文件格式的阅读器
6.  纪录解析器
7.  *可配置的*预处理器
8.  样本队列

### 文件名, 乱序(shuffling), 和最大训练迭代数(epoch limits) <a class="md-anchor" id="AUTOGENERATED-filenames--shuffling--and-epoch-limits"></a>

可以使用字符串张量(比如`["file0", "file1"]`, `[("file%d" % i) for i in range(2)]`， `[("file%d" % i) for i in range(2)]`) 或者[`tf.train.match_filenames_once` 函数](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#match_filenames_once)来产生文件名列表。

将文件名列表交给[`tf.train.string_input_producer` 函数](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#string_input_producer).`string_input_producer`来生成一个先入先出的队列， 文件阅读器会需要它来读取数据。

`string_input_producer` 提供的可配置参数来设置文件名乱序和最大的训练迭代数， `QueueRunner`会为每次迭代(epoch)将所有的文件名加入文件名队列中， 如果`shuffle=True`的话， 会对文件名进行乱序处理。这一过程是比较均匀的，因此它可以产生均衡的文件名队列。

这个`QueueRunner`的工作线程是独立于文件阅读器的线程， 因此乱序和将文件名推入到文件名队列这些过程不会阻塞文件阅读器运行。

### 文件格式 <a class="md-anchor" id="AUTOGENERATED-file-formats"></a>

根据你的文件格式， 选择对应的文件阅读器， 然后将文件名队列提供给阅读器的`read`方法。阅读器的`read`方法会输出一个key来表征输入的文件和其中的纪录(对于调试非常有用)，同时得到一个字符串标量， 这个字符串标量可以被一个或多个解析器，或者转换操作将其解码为张量并且构造成为样本。

#### CSV 文件 <a class="md-anchor" id="AUTOGENERATED-csv-files"></a>

从CSV文件中读取数据， 需要使用[`TextLineReader`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#TextLineReader)和[`decode_csv`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#decode_csv) 操作， 如下面的例子所示：

```python
filename_queue = tf.train.string_input_producer(["file0.csv", "file1.csv"])

reader = tf.TextLineReader()
key, value = reader.read(filename_queue)

# Default values, in case of empty columns. Also specifies the type of the
# decoded result.
record_defaults = [[1], [1], [1], [1], [1]]
col1, col2, col3, col4, col5 = tf.decode_csv(
    value, record_defaults=record_defaults)
features = tf.concat(0, [col1, col2, col3, col4])

with tf.Session() as sess:
  # Start populating the filename queue.
  coord = tf.train.Coordinator()
  threads = tf.train.start_queue_runners(coord=coord)

  for i in range(1200):
    # Retrieve a single instance:
    example, label = sess.run([features, col5])

  coord.request_stop()
  coord.join(threads)
```
每次`read`的执行都会从文件中读取一行内容， `decode_csv` 操作会解析这一行内容并将其转为张量列表。如果输入的参数有缺失，`record_default`参数可以根据张量的类型来设置默认值。

在调用`run`或者`eval`去执行`read`之前， 你必须调用`tf.train.start_queue_runners`来将文件名填充到队列。否则`read`操作会被阻塞到文件名队列中有值为止。

#### 固定长度的记录 <a class="md-anchor" id="AUTOGENERATED-fixed-length-records"></a>

从二进制文件中读取固定长度纪录， 可以使用[`tf.FixedLengthRecordReader`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#FixedLengthRecordReader)的[`tf.decode_raw`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#decode_raw)操作。`decode_raw`操作可以讲一个字符串转换为一个uint8的张量。

举例来说，[the CIFAR-10 dataset](http://www.cs.toronto.edu/~kriz/cifar.html)的文件格式定义是：每条记录的长度都是固定的，一个字节的标签，后面是3072字节的图像数据。uint8的张量的标准操作就可以从中获取图像片并且根据需要进行重组。 例子代码可以在[`tensorflow/models/image/cifar10/cifar10_input.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/models/image/cifar10/cifar10_input.py)找到，具体讲述可参见[教程](tensorflow-zh/SOURCE/tutorials/deep_cnn/index.md#prepare-the-data).

#### 标准TensorFlow格式 <a class="md-anchor" id="AUTOGENERATED-standard-tensorflow-format"></a>

另一种保存记录的方法可以允许你讲任意的数据转换为TensorFlow所支持的格式， 这种方法可以使TensorFlow的数据集更容易与网络应用架构相匹配。这种建议的方法就是使用TFRecords文件，TFRecords文件包含了[`tf.train.Example` 协议内存块(protocol buffer)](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/example/example.proto)(协议内存块包含了字段
[`Features`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/example/feature.proto))。你可以写一段代码获取你的数据， 将数据填入到`Example`协议内存块(protocol buffer)，将协议内存块序列化为一个字符串， 并且通过[`tf.python_io.TFRecordWriter` class](tensorflow-zh/SOURCE/api_docs/python/python_io.md#TFRecordWriter)写入到TFRecords文件。[`tensorflow/g3doc/how_tos/reading_data/convert_to_records.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/g3doc/how_tos/reading_data/convert_to_records.py)就是这样的一个例子。

从TFRecords文件中读取数据， 可以使用[`tf.TFRecordReader`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#TFRecordReader)的[`tf.parse_single_example`](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#parse_single_example)解析器。这个`parse_single_example`操作可以将`Example`协议内存块(protocol buffer)解析为张量。 MNIST的例子就使用了`convert_to_records` 所构建的数据。 请参看[`tensorflow/g3doc/how_tos/reading_data/fully_connected_reader.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/g3doc/how_tos/reading_data/fully_connected_reader.py), 您也可以将这个例子跟`fully_connected_feed`的版本加以比较。

### 预处理 <a class="md-anchor" id="AUTOGENERATED-preprocessing"></a>

你可以对输入的样本进行任意的预处理， 这些预处理不依赖于训练参数， 你可以在[`tensorflow/models/image/cifar10/cifar10.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/models/image/cifar10/cifar10.py)找到数据归一化，提取随机数据片，增加噪声或失真等等预处理的例子。

### 批处理 <a class="md-anchor" id="AUTOGENERATED-batching"></a>

在数据输入管线的末端， 我们需要有另一个队列来执行输入样本的训练，评价和推理。因此我们使用[`tf.train.shuffle_batch` 函数](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#shuffle_batch)来对队列中的样本进行乱序处理

示例:

```
def read_my_file_format(filename_queue):
  reader = tf.SomeReader()
  key, record_string = reader.read(filename_queue)
  example, label = tf.some_decoder(record_string)
  processed_example = some_processing(example)
  return processed_example, label

def input_pipeline(filenames, batch_size, num_epochs=None):
  filename_queue = tf.train.string_input_producer(
      filenames, num_epochs=num_epochs, shuffle=True)
  example, label = read_my_file_format(filename_queue)
  # min_after_dequeue defines how big a buffer we will randomly sample
  #   from -- bigger means better shuffling but slower start up and more
  #   memory used.
  # capacity must be larger than min_after_dequeue and the amount larger
  #   determines the maximum we will prefetch.  Recommendation:
  #   min_after_dequeue + (num_threads + a small safety margin) * batch_size
  min_after_dequeue = 10000
  capacity = min_after_dequeue + 3 * batch_size
  example_batch, label_batch = tf.train.shuffle_batch(
      [example, label], batch_size=batch_size, capacity=capacity,
      min_after_dequeue=min_after_dequeue)
  return example_batch, label_batch
```

如果你需要对不同文件中的样子有更强的乱序和并行处理，可以使用[`tf.train.shuffle_batch_join` 函数](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#shuffle_batch_join).
示例:

```
def read_my_file_format(filename_queue):
  # Same as above

def input_pipeline(filenames, batch_size, read_threads, num_epochs=None):
  filename_queue = tf.train.string_input_producer(
      filenames, num_epochs=num_epochs, shuffle=True)
  example_list = [read_my_file_format(filename_queue)
                  for _ in range(read_threads)]
  min_after_dequeue = 10000
  capacity = min_after_dequeue + 3 * batch_size
  example_batch, label_batch = tf.train.shuffle_batch_join(
      example_list, batch_size=batch_size, capacity=capacity,
      min_after_dequeue=min_after_dequeue)
  return example_batch, label_batch
```

在这个例子中， 你虽然只使用了一个文件名队列， 但是TensorFlow依然能保证多个文件阅读器从同一次迭代(epoch)的不同文件中读取数据，知道这次迭代的所有文件都被开始读取为止。（通常来说一个线程来对文件名队列进行填充的效率是足够的）

另一种替代方案是： 使用[`tf.train.shuffle_batch` 函数](tensorflow-zh/SOURCE/api_docs/python/io_ops.md#shuffle_batch),设置`num_threads`的值大于1。 这种方案可以保证同一时刻只在一个文件中进行读取操作(但是读取速度依然优于单线程)，而不是之前的同时读取多个文件。这种方案的优点是：
*   避免了两个不同的线程从同一个文件中读取同一个样本。
*   避免了过多的磁盘搜索操作。

你一共需要多少个读取线程呢？ 函数`tf.train.shuffle_batch*`为TensorFlow图提供了获取文件名队列中的元素个数之和的方法。 如果你有足够多的读取线程， 文件名队列中的元素个数之和应该一直是一个略高于0的数。具体可以参考[TensorBoard:可视化学习](tensorflow-zh/SOURCE/how_tos/summaries_and_tensorboard/index.md).

### 创建线程并使用`QueueRunner`对象来预取 <a class="md-anchor" id="QueueRunner"></a>

简单来说：使用上面列出的许多`tf.train`函数添加[`QueueRunner`](../../api_docs/python/train.md#QueueRunner)到你的数据流图中。在你运行任何训练步骤之前，需要调用[`tf.train.start_queue_runners`](../../api_docs/python/train.md#start_queue_runners)函数，否则数据流图将一直挂起。[`tf.train.start_queue_runners`](../../api_docs/python/train.md#start_queue_runners) 这个函数将会启动输入管道的线程，填充样本到队列中，以便出队操作可以从队列中拿到样本。这种情况下最好配合使用一个[`tf.train.Coordinator`](../../api_docs/python/train.md#Coordinator)，这样可以在发生错误的情况下正确地关闭这些线程。如果你对训练迭代数做了限制，那么需要使用一个训练迭代数计数器，并且需要被初始化。推荐的代码模板如下：

```python
# Create the graph, etc.
init_op = tf.initialize_all_variables()

# Create a session for running operations in the Graph.
sess = tf.Session()

# Initialize the variables (like the epoch counter).
sess.run(init_op)

# Start input enqueue threads.
coord = tf.train.Coordinator()
threads = tf.train.start_queue_runners(sess=sess, coord=coord)

try:
    while not coord.should_stop():
        # Run training steps or whatever
        sess.run(train_op)

except tf.errors.OutOfRangeError:
    print 'Done training -- epoch limit reached'
finally:
    # When done, ask the threads to stop.
    coord.request_stop()

# Wait for threads to finish.
coord.join(threads)
sess.close()
```

#### 疑问: 这是怎么回事? <a class="md-anchor" id="AUTOGENERATED-aside--what-is-happening-here-"></a>

首先，我们先创建数据流图，这个数据流图由一些流水线的阶段组成，阶段间用队列连接在一起。第一阶段将生成文件名，我们读取这些文件名并且把他们排到文件名队列中。第二阶段从文件中读取数据（使用`Reader`），产生样本，而且把样本放在一个样本队列中。根据你的设置，实际上也可以拷贝第二阶段的样本，使得他们相互独立，这样就可以从多个文件中并行读取。在第二阶段的最后是一个排队操作，就是入队到队列中去，在下一阶段出队。因为我们是要开始运行这些入队操作的线程，所以我们的训练循环会使得样本队列中的样本不断地出队。

<div style="width:70%; margin-left:12%; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../images/AnimatedFileQueues.gif">
</div>

在`tf.train`中要创建这些队列和执行入队操作，就要添加[`tf.train.QueueRunner`](../../api_docs/python/train.md#QueueRunner)到一个使用[`tf.train.add_queue_runner`](../../api_docs/python/train.md#add_queue_runner)函数的数据流图中。每个`QueueRunner`负责一个阶段，处理那些需要在线程中运行的入队操作的列表。一旦数据流图构造成功，[`tf.train.start_queue_runners`](../../api_docs/python/train.md#start_queue_runners)函数就会要求数据流图中每个`QueueRunner`去开始它的线程运行入队操作。

如果一切顺利的话，你现在可以执行你的训练步骤，同时队列也会被后台线程来填充。如果您设置了最大训练迭代数，在某些时候，样本出队的操作可能会得到一个[`tf.OutOfRangeError`](../../api_docs/python/client.md#OutOfRangeError)的错误。这其实是TensorFlow的“文件结束”（EOF） ———— 这就意味着已经达到了最大训练迭代数，已经没有更多可用的样本了。

最后一个因素是[`Coordinator`](../../api_docs/python/train.md#Coordinator)。这是负责在收到任何关闭信号的时候，让所有的线程都知道。最常用的是在发生异常时这种情况就会呈现出来，比如说其中一个线程在运行某些操作时出现错误（或一个普通的Python异常）。

想要了解更多的关于threading, queues, QueueRunners, and Coordinators的内容可以[看这里](../../how_tos/threading_and_queues/index.md).

#### 疑问: 在达到最大训练迭代数的时候如何清理关闭线程? <a class="md-anchor" id="AUTOGENERATED-aside--how-clean-shut-down-when-limiting-epochs-works"></a>

想象一下，你有一个模型并且设置了最大训练迭代数。这意味着，生成文件的那个线程将只会在产生`OutOfRange`错误之前运行许多次。该`QueueRunner`会捕获该错误，并且关闭文件名的队列，最后退出线程。关闭队列做了两件事情：

*   如果还试着对文件名队列执行入队操作时将发生错误。任何线程不应该尝试去这样做，但是当队列因为其他错误而关闭时，这就会有用了。
*   任何当前或将来出队操作要么成功（如果队列中还有足够的元素）或立即失败（发生`OutOfRange`错误）。它们不会防止等待更多的元素被添加到队列中，因为上面的一点已经保证了这种情况不会发生。

关键是，当在文件名队列被关闭时候，有可能还有许多文件名在该队列中，这样下一阶段的流水线（包括reader和其它预处理）还可以继续运行一段时间。 一旦文件名队列空了之后，如果后面的流水线还要尝试从文件名队列中取出一个文件名（例如，从一个已经处理完文件的reader中），这将会触发`OutOfRange`错误。在这种情况下，即使你可能有一个QueueRunner关联着多个线程。如果这不是在QueueRunner中的最后那个线程，`OutOfRange`错误仅仅只会使得一个线程退出。这使得其他那些正处理自己的最后一个文件的线程继续运行，直至他们完成为止。 （但如果假设你使用的是[`tf.train.Coordinator`](../../api_docs/python/train.md#Coordinator)，其他类型的错误将导致所有线程停止）。一旦所有的reader线程触发`OutOfRange`错误，然后才是下一个队列，再是样本队列被关闭。

同样，样本队列中会有一些已经入队的元素，所以样本训练将一直持续直到样本队列中再没有样本为止。如果样本队列是一个[`RandomShuffleQueue`](../../api_docs/python/io_ops.md#RandomShuffleQueue)，因为你使用了`shuffle_batch` 或者 `shuffle_batch_join`，所以通常不会出现以往那种队列中的元素会比`min_after_dequeue` 定义的更少的情况。 然而，一旦该队列被关闭，`min_after_dequeue`设置的限定值将失效，最终队列将为空。在这一点来说，当实际训练线程尝试从样本队列中取出数据时，将会触发`OutOfRange`错误，然后训练线程会退出。一旦所有的培训线程完成，[`tf.train.Coordinator.join`](../../api_docs/python/train.md#Coordinator.join)会返回，你就可以正常退出了。

### 筛选记录或产生每个记录的多个样本 <a class="md-anchor" id="AUTOGENERATED-filtering-records-or-producing-multiple-examples-per-record"></a>

举个例子，有形式为`[x, y, z]`的样本，我们可以生成一批形式为`[batch, x, y, z]`的样本。 如果你想滤除这个记录（或许不需要这样的设置），那么可以设置batch的大小为0；但如果你需要每个记录产生多个样本，那么batch的值可以大于1。 然后很简单，只需调用批处理函数（比如： `shuffle_batch` or `shuffle_batch_join`）去设置`enqueue_many=True`就可以实现。

### 稀疏输入数据 <a class="md-anchor" id="AUTOGENERATED-sparse-input-data"></a>

SparseTensors这种数据类型使用队列来处理不是太好。如果要使用SparseTensors你就必须在批处理**之后**使用[`tf.parse_example`](../../api_docs/python/io_ops.md#parse_example) 去解析字符串记录 (而不是在批处理**之前**使用 `tf.parse_single_example`) 。

## 预取数据 <a class="md-anchor" id="AUTOGENERATED-preloaded-data"></a>

这仅用于可以完全加载到存储器中的小的数据集。有两种方法：

* 存储在常数中。
* 存储在变量中，初始化后，永远不要改变它的值。

使用常数更简单一些，但是会使用更多的内存（因为常数会内联的存储在数据流图数据结构中，这个结构体可能会被复制几次）。

```python
training_data = ...
training_labels = ...
with tf.Session():
  input_data = tf.constant(training_data)
  input_labels = tf.constant(training_labels)
  ...
```

要改为使用变量的方式，您就需要在数据流图建立后初始化这个变量。

```python
training_data = ...
training_labels = ...
with tf.Session() as sess:
  data_initializer = tf.placeholder(dtype=training_data.dtype,
                                    shape=training_data.shape)
  label_initializer = tf.placeholder(dtype=training_labels.dtype,
                                     shape=training_labels.shape)
  input_data = tf.Variable(data_initalizer, trainable=False, collections=[])
  input_labels = tf.Variable(label_initalizer, trainable=False, collections=[])
  ...
  sess.run(input_data.initializer,
           feed_dict={data_initializer: training_data})
  sess.run(input_labels.initializer,
           feed_dict={label_initializer: training_lables})
```

设定`trainable=False` 可以防止该变量被数据流图的 `GraphKeys.TRAINABLE_VARIABLES` 收集, 这样我们就不会在训练的时候尝试更新它的值； 设定 `collections=[]` 可以防止`GraphKeys.VARIABLES` 收集后做为保存和恢复的中断点。

无论哪种方式，[`tf.train.slice_input_producer function`](../../api_docs/python/io_ops.md#slice_input_producer)函数可以被用来每次产生一个切片。这样就会让样本在整个迭代中被打乱，所以在使用批处理的时候不需要再次打乱样本。所以我们不使用`shuffle_batch`函数，取而代之的是纯[`tf.train.batch` 函数](../../api_docs/python/io_ops.md#batch)。 如果要使用多个线程进行预处理，需要将`num_threads`参数设置为大于1的数字。

在[`tensorflow/g3doc/how_tos/reading_data/fully_connected_preloaded.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/g3doc/how_tos/reading_data/fully_connected_preloaded.py) 中可以找到一个MNIST例子，使用常数来预加载。 另外使用变量来预加载的例子在[`tensorflow/g3doc/how_tos/reading_data/fully_connected_preloaded_var.py`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/g3doc/how_tos/reading_data/fully_connected_preloaded_var.py)，你可以用上面 `fully_connected_feed` 和 `fully_connected_reader` 的描述来进行比较。

## 多输入管道 <a class="md-anchor" id="AUTOGENERATED-multiple-input-pipelines"></a>

通常你会在一个数据集上面训练，然后在另外一个数据集上做评估计算(或称为 "eval")。 这样做的一种方法是，实际上包含两个独立的进程：

* 训练过程中读取输入数据，并定期将所有的训练的变量写入还原点文件）。
* 在计算过程中恢复还原点文件到一个推理模型中，读取有效的输入数据。

这两个进程在下面的例子中已经完成了：[the example CIFAR-10 model](../../tutorials/deep_cnn/index.md#save-and-restore-checkpoints)，有以下几个好处：

* eval被当做训练后变量的一个简单映射。
* 你甚至可以在训练完成和退出后执行eval。

您可以在同一个进程的相同的数据流图中有训练和eval，并分享他们的训练后的变量。参考[the shared variables tutorial](../../how_tos/variable_scope/index.md).

原文地址：[Reading data](https://github.com/jikexueyuanwiki/tensorflow-zh/blob/master/SOURCE/how_tos/reading_data/index.md) 翻译：[volvet](https://github.com/volvet) and [zhangkom](https://github.com/zhangkom) 校对：
